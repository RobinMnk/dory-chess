//
// Created by Robin on 17.07.2022.
//

#ifndef DORY_MOVECOLLECTORS_H
#define DORY_MOVECOLLECTORS_H

#include <unordered_map>
#include <vector>
#include <iostream>

#include "movegen.h"
#include "../utils/utils.h"

/**
 * A namespace containing various classes for collecting the moves generated by movegen.
 */
namespace Dory::MoveCollectors {

    /**
     * Fastest Movecollector, but tree depth has to be known at compiletime!
     *
     * @tparam saveBoards - whether resulting boards at lowest level should be saved in 'positions'
     * @tparam print - whether moves should be printed to stdout. Only recommended for very small depths
     */
    template<int depth>
    class LimitedDFS {
    public:
        static unsigned long long totalNodes;

        template<bool whiteToMove>
        static void generateGameTree(const Board& board) {
//            if constexpr (depth == 1) {
//                MoveGenerator<LimitedDFS<depth>, false, true>::template generate<state>(board);
//                totalNodes += MoveGenerator<LimitedDFS<depth>, false, true>::numberOfMoves;
////                for (int num_moves: MoveGenerator<LimitedDFS<depth>, false, true>::numberOfMovesByPiece) {
////                    totalNodes += num_moves;
////                }
//            }
//            else
            if constexpr (depth > 0) {
                MoveGenerator<LimitedDFS<depth>>::template generate<whiteToMove>(board);
            }
        }

    private:
        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(const Board& board, BB from, BB to) {
            if constexpr (depth == 1) {
                totalNodes++;
            }

            Board nextBoard = board.fork<whiteToMove, piece, flags>(from, to);
            LimitedDFS<depth-1>::template generateGameTree<!whiteToMove>(nextBoard);
        }

        friend class MoveGenerator<LimitedDFS<depth>>;
    };

    template<int depth>
    unsigned long long LimitedDFS<depth>::totalNodes{0};


    struct QuickCollector {
        static BB targets;

        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(const Board &board, BB from, BB to) {
            targets |= to;
        }
    };

    /**
     * Forwards nextMove call to given object. If template deduction fails here, make sure the function
     * nextMove<whiteToMove, piece, flags>(board, from, to) exists with the correct signature on type T.
     */
    template<typename T, bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
    requires ValidMoveCollectorObj<T, whiteToMove, piece, flags>
    void forward(T* obj, const Board& board, BB from, BB to) {
        obj->template nextMove<whiteToMove, piece, flags>(board, from, to);
    }

    template<typename T>
    class ObjectCollector {
        static T* _ref;

        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(const Board& board, BB from, BB to) {
            forward<T, whiteToMove, piece, flags>(_ref, board, from, to);
        }
        friend class MoveGenerator<ObjectCollector>;

    public:
        template<bool whiteToMove, GenerationConfig config=GC_DEFAULT>
        static void generate(T* ref, const Board& board) {
            _ref = ref;
            MoveGenerator<ObjectCollector<T>>::template generate<whiteToMove, config>(board);
        }
    };

    template<typename T, bool whiteToMove, GenerationConfig config=GC_DEFAULT>
    void generateMoves(T* ref, const Board& board) {
        ObjectCollector<T>::generate<whiteToMove, config>(ref, board);
    }

    // Example for using class as MoveCollector
    struct A {
        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        void nextMove(const Board& board, BB from, BB to) const {

        }

        template<bool whiteToMove>
        void generate(const Board& board) {
            generateMoves<A, whiteToMove>(this, board);
        }
    };


    static std::vector<unsigned long long> nodes;

    template<int depth>
    class PerftCollector {
        using Generator = MoveGenerator<PerftCollector<depth>>;
        friend Generator;
    public:
        template<bool whiteToMove>
        static void generateGameTree(const Board& board) {
            if constexpr (depth == 1) {
                Generator::numberOfMoves = 0;
                Generator::template generate<whiteToMove, GC_COUNT_ONLY>(board);
                nodes.at(depth) += Generator::numberOfMoves;
            } else if constexpr (depth > 0) {
                Generator::template generate<whiteToMove>(board);
            }
        }

    private:
        template<bool whiteToMove,  Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(const Board& board, BB from, BB to) {
            nodes.at(depth)++;
            Board nextBoard = board.fork<whiteToMove, piece, flags>(from, to);
            PerftCollector<depth-1>::template generateGameTree<!whiteToMove>(nextBoard);
        }
    };

    /**
     * A Movecollector for listing the divide output for a given position.
     * For every legal move the number of resulting follow-up positions at the given depth is calculated.
     * Used mainly for debugging purposes.
     */
    class Divide {
    public:
        static std::vector<std::string> moves;
        static std::vector<uint64_t> nodes;
        static unsigned long long curr, totalNodes;
        static int maxDepth;

        template<bool whiteToMove, int depth>
        static void generateGameTree(Board& board) {
            maxDepth = depth;
            build<whiteToMove, depth>(board);
        }

        static void print() {
            for(unsigned int i{0}; i < curr; i++) {
                std::cout << moves.at(i) << ": " << nodes.at(i) << std::endl;
            }

            std::cout << "\nTotal nodes searched: " << totalNodes << std::endl;
        }

    private:
        template<bool whiteToMove, int depth>
        static void build(Board& board) {
            if constexpr (depth > 0) {
                MoveGenerator<Divide>::template generate<whiteToMove, depth>(board);
            }
        }

        template<bool whiteToMove, int depth, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove([[maybe_unused]] const Board &board, BB from, BB to) {
            if (depth == maxDepth) {
                Move m = createMoveFromBB(from, to, piece, flags);
                moves.push_back(Utils::moveNameShort(m));
                nodes.push_back(0);
                curr++;
            }

            if constexpr(depth == 1) {
                nodes.back()++;
                totalNodes++;
            }
        }

        template<bool whiteToMove, int depth>
        static void next(Board& nextBoard) {
            build<!whiteToMove, depth-1>(nextBoard);
        }

        static void done() {
        }

        friend class MoveGenerator<Divide>;
    };

    std::vector<std::string> Divide::moves{};
    std::vector<uint64_t> Divide::nodes{};
    unsigned long long Divide::curr{0};
    unsigned long long Divide::totalNodes{0};
    int Divide::maxDepth{1};

} // namespace Dory::MoveCollectors

#endif //DORY_MOVECOLLECTORS_H
