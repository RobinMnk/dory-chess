//
// Created by Robin on 17.07.2022.
//

#ifndef DORY_MOVECOLLECTORS_H
#define DORY_MOVECOLLECTORS_H

#include <unordered_map>
#include <vector>
#include <iostream>

#include "movegen.h"
#include "../utils/utils.h"

/**
 * A namespace containing various classes for collecting the moves generated by movegen.
 */
namespace Dory::MoveCollectors {

    /**
     * Fastest Movecollector, but tree depth has to be known at compiletime!
     *
     * @tparam saveBoards - whether resulting boards at lowest level should be saved in 'positions'
     * @tparam print - whether moves should be printed to stdout. Only recommended for very small depths
     */
    template<int depth>
    class LimitedDFS {
        using Generator = MoveGenerator<LimitedDFS<depth>>;
        friend Generator;
    public:
        static unsigned long long totalNodes;

        template<bool whiteToMove>
        static inline void generateGameTree(Board& board) {
            if constexpr (depth == 1) {
                Generator::template generate<whiteToMove, GC_COUNT_ONLY>(board);
                totalNodes += Generator::numberOfMoves;
            } else
            if constexpr (depth > 0) {
                Generator::template generate<whiteToMove>(board);
            }
        }

    private:
        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(Board& board, BB from, BB to) {
            RestoreInfo ri = board.makeMove<whiteToMove, piece, flags>(from, to);
            LimitedDFS<depth-1>::template generateGameTree<!whiteToMove>(board);
            board.unmakeMove<whiteToMove, piece, flags>(from, to, ri);

//            Board nextBoard = board.fork<whiteToMove, piece, flags>(from, to);
//            LimitedDFS<depth-1>::template generateGameTree<!whiteToMove>(nextBoard);
        }
    };

    template<int depth>
    unsigned long long LimitedDFS<depth>::totalNodes{0};


//    struct QuickCollector {
//        static BB targets;
//
//        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
//        static void nextMove(Board &board, BB from, BB to) {
//            targets |= to;
//        }
//    };

    /**
     * Forwards nextMove call to given object. If template deduction fails here, make sure the function
     * nextMove<whiteToMove, piece, flags>(board, from, to) exists with the correct signature on type T.
     */
    template<typename T, bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
    requires ValidMoveCollectorObj<T, whiteToMove, piece, flags>
    void forward(T* obj, Board& board, BB from, BB to) {
        obj->template nextMove<whiteToMove, piece, flags>(board, from, to);
    }

    template<typename T>
    class ObjectCollector {
        static T* _ref;

        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(Board& board, BB from, BB to) {
            forward<T, whiteToMove, piece, flags>(_ref, board, from, to);
        }
        friend class MoveGenerator<ObjectCollector>;

    public:
        template<bool whiteToMove, GenerationConfig config=GC_DEFAULT>
        static void generate(T* ref, Board& board) {
            _ref = ref;
            MoveGenerator<ObjectCollector<T>>::template generate<whiteToMove, config>(board);
        }

        template<bool whiteToMove, GenerationConfig config=GC_DEFAULT>
        static void generate(T* ref, Board& board, PinData& pd) {
            _ref = ref;
            MoveGenerator<ObjectCollector<T>>::template generate<whiteToMove, config>(board, pd);
        }
    };

    template<typename T>
    T* ObjectCollector<T>::_ref = nullptr;

    template<typename T, bool whiteToMove, GenerationConfig config=GC_DEFAULT>
    void generateMoves(T* ref, Board& board) {
        ObjectCollector<T>::template generate<whiteToMove, config>(ref, board);
    }

    template<typename T, bool whiteToMove, GenerationConfig config=GC_DEFAULT>
    void generateMoves(T* ref, Board& board, PinData& pd) {
        ObjectCollector<T>::template generate<whiteToMove, config>(ref, board, pd);
    }

//    Example for using class as MoveCollector
//    struct A {
//        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
//        void nextMove(Board& board, BB from, BB to) const {
//
//        }
//
//        template<bool whiteToMove>
//        void generate(Board& board) {
//            generateMoves<A, whiteToMove>(this, board);
//        }
//    };


    static std::vector<unsigned long long> nodes;

    template<int depth>
    class PerftCollector {
        using Generator = MoveGenerator<PerftCollector<depth>>;
        friend Generator;
    public:
        template<bool whiteToMove>
        static inline void generateGameTree(Board& board) {
            if constexpr (depth == 1) {
                Generator::template generate<whiteToMove, GC_COUNT_ONLY>(board);
                nodes.at(depth) += Generator::numberOfMoves;
            } else if constexpr (depth > 0) {
                Generator::template generate<whiteToMove>(board);
            }
        }

    private:
        template<bool whiteToMove,  Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(Board& board, BB from, BB to) {
            nodes.at(depth)++;

            RestoreInfo ri = board.makeMove<whiteToMove, piece, flags>(from, to);
            PerftCollector<depth-1>::template generateGameTree<!whiteToMove>(board);
            board.unmakeMove<whiteToMove, piece, flags>(from, to, ri);
        }
    };

    /**
     * A Movecollector for listing the divide output for a given position.
     * For every legal move the number of resulting follow-up positions at the given depth is calculated.
     * Used mainly for debugging purposes.
     */
    template<int depth>
    class Divide {
    public:
        static std::vector<std::string> moves;
        static std::vector<uint64_t> nodes;
        static unsigned long long totalNodes;

        template<bool whiteToMove>
        static void generateGameTree(Board& board) {
            if constexpr (depth == 0) {
                Generator::template generate<whiteToMove, GC_COUNT_ONLY>(board);
                totalNodes += Generator::numberOfMoves;
            } else if constexpr (depth > 0) {
                Generator::template generate<whiteToMove>(board);
            }
        }

        static void print() {
            for(unsigned int i{0}; i < nodes.size(); i++) {
                std::cout << moves.at(i) << ": " << nodes.at(i) << std::endl;
            }

            std::cout << "\n" << nodes.size() << " legal moves. Total nodes searched: " << totalNodes << std::endl;
        }

    private:
        using Generator = MoveGenerator<Divide>;
        friend Generator;

        template<bool whiteToMove, Piece_t piece, Flag_t flags = MOVEFLAG_Silent>
        static void nextMove(Board &board, BB from, BB to) {
            Move m = createMoveFromBB(from, to, piece, flags);
            moves.push_back(Utils::moveNameShort(m));

            RestoreInfo ri = board.makeMove<whiteToMove, piece, flags>(from, to);

            LimitedDFS<1>::totalNodes = 0;
            LimitedDFS<depth-1>::template generateGameTree<!whiteToMove>(board);
            nodes.push_back(LimitedDFS<1>::totalNodes);
            totalNodes += LimitedDFS<1>::totalNodes;

            board.unmakeMove<whiteToMove, piece, flags>(from, to, ri);
        }
    };

    template<int depth>
    std::vector<std::string> Divide<depth>::moves{};

    template<int depth>
    std::vector<uint64_t> Divide<depth>::nodes{};

    template<int depth>
    unsigned long long Divide<depth>::totalNodes{0};

} // namespace Dory::MoveCollectors

#endif //DORY_MOVECOLLECTORS_H
